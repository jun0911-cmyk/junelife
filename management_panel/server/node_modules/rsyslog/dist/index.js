"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const joi = require("joi");
const os_1 = require("os");
const net_1 = require("net");
const dgram_1 = require("dgram");
const events_1 = require("events");
_a = require('../package.json'), exports.name = _a.name, exports.version = _a.version;
const debug = require('debug')(exports.name);
// https://tools.ietf.org/html/rfc5424#section-6.2.1
exports.FACILITY = {
    kern: 0,
    user: 1,
    mail: 2,
    daemon: 3,
    auth: 4,
    syslog: 5,
    lpr: 6,
    news: 7,
    uucp: 8,
    cron: 9,
    security: 10,
    ftp: 11,
    ntp: 12,
    logaudit: 13,
    logalert: 14,
    clock: 15,
    local0: 16,
    local1: 17,
    local2: 18,
    local3: 19,
    local4: 20,
    local5: 21,
    local6: 22,
    local7: 23,
};
exports.SEVERITY = {
    EMERG: 0,
    ALERT: 1,
    CRIT: 2,
    ERROR: 3,
    WARNING: 4,
    NOTICE: 5,
    INFO: 6,
    DEBUG: 7,
};
exports.NILVALUE = '-';
exports.BOM = new Buffer('EFBBBF', 'hex');
const DELIMITER = new Buffer(' ', 'ascii');
const optionsSchema = joi.object({
    target_host: joi.string().empty(null).default('127.0.0.1'),
    target_port: joi.number().integer().empty(null).default(514),
    hostname: joi.string().default(os_1.hostname()),
    appname: joi.string().default(exports.NILVALUE),
    facility: joi.alternatives([
        joi.string().empty(null).valid(Object.keys(exports.FACILITY)),
        joi.number().integer().min(0).max(23),
    ]).default(exports.FACILITY.local0),
    procid: joi.string().default(process.pid),
}).default();
const severitySchema = joi.number().integer().min(0).max(7);
const sendOptionsSchema = joi.object({
    timestamp: joi.number().integer().default(0),
    msgid: joi.string().default(exports.NILVALUE),
}).default();
const messageSchema = joi.string().min(1).max(1024);
/**
 * A remote syslog client. Sends over UDP.
 */
class RemoteSyslog extends events_1.EventEmitter {
    constructor(options) {
        options = joi.attempt(options, optionsSchema);
        debug('constructing...', options);
        super();
        this.options = Object.assign({}, options, { facility: getFacilityCode(options.facility) });
        this.pending = [];
        this.handleSendResult = this.handleSendResult.bind(this);
        this.running = false;
    }
    /**
     * Create an open a socket, if necessary.
     * Either way, return it.
     */
    connect() {
        if (this.socket) {
            return this.socket;
        }
        else {
            const version = net_1.isIPv6(this.options.target_host) ? 'udp6' : 'udp4';
            debug(`socket opening (${version})`);
            const socket = this.socket = dgram_1.createSocket({
                reuseAddr: true,
                type: version,
            });
            this.socket.on('close', () => this.socketClose());
            this.socket.on('error', err => this.socketError(err));
            this.socket.unref();
            debug(`socket open`);
            return socket;
        }
    }
    /**
     * Handle the socket's `close` event'.
     */
    socketClose() {
        debug('socket closed');
        this.socket = null;
    }
    /**
     * Propagate the socket's `error` event.
     */
    socketError(err) {
        debug('socket error', err.message);
        this.emit('error', err);
        this.disconnect();
    }
    /**
     * Close the socket, if it's still open.
     */
    disconnect() {
        if (this.socket) {
            debug('socket closing...');
            this.socket.close();
            this.socket = null;
        }
    }
    /**
     * Send a message to the remote syslogd. Pretends to be synchronous.
     */
    send(severity, message, options) {
        severity = joi.attempt(severity, severitySchema);
        message = joi.attempt(message, messageSchema);
        options = joi.attempt(options, sendOptionsSchema);
        const facility = this.options.facility;
        const priority = facility << 3 | severity;
        const { hostname, appname, procid } = this.options;
        const { timestamp, msgid } = options;
        const tsrep = new Date(timestamp || Date.now()).toISOString();
        const header = `<${priority}>1 ${tsrep} ${hostname} ${appname} ${procid} ${msgid}`;
        const structured = exports.NILVALUE;
        const buf = Buffer.concat([
            new Buffer(header, 'ascii'),
            DELIMITER,
            new Buffer(structured, 'ascii'),
            DELIMITER,
            exports.BOM,
            new Buffer(message, 'utf8'),
        ]);
        this.queueMessage(buf);
    }
    /**
     * Queue another buffer to be sent.
     */
    queueMessage(buf) {
        debug('queue', buf.toString());
        this.pending.push(buf);
        this.start();
    }
    /**
     * Send the next message.
     */
    sendNextMessage() {
        if (!this.pending.length) {
            debug('spurious sendNextMessage');
            this.stop();
            return;
        }
        const buf = this.pending.shift();
        this.continue();
        if (!buf) {
            debug('undefined buf');
            return;
        }
        try {
            const socket = this.connect();
            const { target_port, target_host } = this.options;
            socket.send(buf, 0, buf.byteLength, target_port, target_host, this.handleSendResult);
        }
        catch (err) {
            this.handleSendResult(err);
        }
    }
    /**
     * Handle send results. On errors, report them upstream. That could be
     * ignored, result in our destruction and re-creation, or result in the
     * process crashing. So, we keep sending anyway, as we're the only object
     * with a reference to the unsent messages.
     */
    handleSendResult(err, bytes) {
        if (err) {
            debug('error', err);
            this.emit('error', err);
        }
        else {
            debug('sent', bytes);
        }
    }
    /**
     * Start sending.
     */
    start() {
        if (!this.running) {
            this.running = true;
            this.continue();
        }
    }
    /**
     * Continue sending if there are more packets, else stop.
     */
    continue() {
        if (this.pending.length) {
            setImmediate(() => this.sendNextMessage());
        }
        else {
            this.stop();
        }
    }
    /**
     * Stop sending.
     */
    stop() {
        if (this.running) {
            this.running = false;
        }
    }
}
exports.RemoteSyslog = RemoteSyslog;
/**
 * Get a facility code from a facility code, stringifified code, or name.
 */
function getFacilityCode(facility) {
    const int = parseInt('facility', 10);
    if (typeof facility === 'number') {
        return facility;
    }
    else if (!isNaN(int)) {
        return int;
    }
    else if (facility in exports.FACILITY) {
        return exports.FACILITY[facility];
    }
    else {
        throw new Error(`bad facility: ${facility}`);
    }
}
var _a;
//# sourceMappingURL=index.js.map